TODO next:
- add input logs / output logs to the game
- start using some snapshot testing

on the interaction between game and player:

- think we need to split up the concept of "agent" (something that makes
  decisions) vs "player" (an agent plus some cards)
- how can borrows work for game.play_one_turn()?
  - the function itself needs to borrow the game as &mut self
  - but we need the agent to try and mutate the game state too
  - play_one_turn can't pass another &mut self borrow to agent.do_actions()
    since it's already got an exclusive borrow of itself.
  - do we need to RefCell a lot to make these kinds of designs work?
  - the easier thing to do would be to ask the agent to return an object
    representing the decision (rather than the agent sending messages to the
    game for its decisions) but that's moving more away from the OOP style.
  - trying to be OOP does feel like we're fighting rust a fair bit - maybe
    it's just not the best language for this style?

seriously considering just falling back to more functional style in order
to get stuff done.

-------------------------------------------------------------------------------

thinking about the design of play_area:
- the abstraction we'd really like to have is something like "card supply" - ie
  a thing that we draw cards from each turn, and then put cards back into.
  That way it's easier to mock out saying "the player draws X cards in this
  particular turn" for other cases.
- it feels maybe a little less OO that way, though? let's keep going with what
  we have and see what happens.

game and play_area are still disjointed. Probably need to do a lot more work
from the game side to try and join them up (or find more useful abstractions to
build)

https://wiki.dominionstrategy.com/index.php/Triggered_effects
https://wiki.dominionstrategy.com/index.php/Turn
https://wiki.dominionstrategy.com/index.php/Gameplay

-------------------------------------------------------------------------------

https://github.com/mitsuhiko/insta could be better for testing actual games as
opposed to individual components.

-------------------------------------------------------------------------------

thinking about how we'd test a game:

- the first thing that happens is shuffling the deck and drawing five cards
  - we need to make sure that the shuffle is deterministic in a test
  - need some kind of seeded random
  - just relying on the seed seems fragile, though - a slight change in the
    shuffle algorithm, the randomness, the deck implementation or something
    else could mean the test breaks
  - plus it's not clear in a test how a seed like "5" means the first turns
    are a 3-4 or 5-2 copper split.
- so trying to rethink this from an OO perspective:
  - what we really want is to be able to say "the player draws these exact
    cards in this order"
  - what we're missing is a Deck abstraction
  - either the deck can be implemented as a proper random deck (with seeding
    still required for undos/replays) or as a test deck which returns certain
    cards in order.

outstanding questions:

- do we model the deck by itself, or is it worth pairing the deck and discard
  pile together?

-------------------------------------------------------------------------------

a bit tough figuring out where to start with the unit tests

jumped from a high-level game test to a card / turnstate test, but don't really
know how to connect the two

should probably back off from the second test and try to actually drive the
design with more high-level tests?

-------------------------------------------------------------------------------

ideas for interesting things to try and model:

- most basic place to start: just basic treasures and victory cards?
    - only need a buy phase
- then maybe some basic actions
    - +1 card +1 action
    - chapel?
- important thing: get good at printing out a log early
- interesting thing to try: recursive cards / action stack?
- interesting thing to try: attack cards
    - giving players a chance to respond to cards
    - callbacks like “some other player has revealed their cards”
- interesting thing to try: duration cards
    - actual duration cards which sit in the ‘set aside’ area until triggered
    - implement cards like Wharf as fake duration cards? eg they leave some kind
      of token in the ‘set aside’ area until triggered
      - in fact making Token a first-class thing like Card could be cool
        - unlike cards, tokens can be created and destroyed
        - tokens can be placed on specific cards or supply piles
        - tokens have some kind of effect which resolves once or multiple times
    - interactivity: choice of which effects to trigger in order
        - could just make this arbitrary to begin with
- interesting thing to try: card which lowers all costs for duration of turn
- interesting rules: https://wiki.dominionstrategy.com/index.php/Stop-moving_rule
  and linked pages
- fun cards to try implementing:
    - extra-turn or skip-turn cards like outpost, lich or **possession**

-------------------------------------------------------------------------------

thinking about possible approaches
mostly OOP vs functional

OOP: card.play(game_state) mutates the game state in whatever way it wants
  - makes implementing undo/rewind tricky  
    (event sourcing might be the solution?)
  - means fewer things have to be explicitly modeled as data
  - might make stacked game states (like in Possession) easier to implement
    by intercepting calls?
functional: playCard(card, game_state) -> (new_game_state, effects)
  - basically the ELM architecture?
  - undo is trivial since the old game state is unaffected
  - could try to use persistent data structures to share data between old and
    new game states

